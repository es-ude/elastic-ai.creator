== Time Multiplexed Implementation

=== Components

==== Sliding Window

[pikchr]
----
FULL: [box "t0"; box "t1"; box "t2"; box "t3"; box "t4"; box "t5"; box "t6"]

move down 2cm from FULL.sw
right
T2: [box "t0"; box "t1"; box "t2"]
move down 2cm from T2.sw;
right;
T3: [box "t1"; box "t2"; box "t3"]
move down 2cm from T3.sw;
right;
T4: [box "t2"; box "t3"; box "t4"]

text "At time t2" with .e at T2.w
text "At time t3" with .e at T3.w
text "At time t4" with .e at T4.w
text "Full input data, ie. full sample" with .e at FULL.w
----

==== Shift Register

[pikchr]
----
T2: [box "t0"; box "t1"; box "t2"]

move down 2cm from T2.sw;
right
T3: [box "t1"; box "t2"; box "t3"]
move down 2cm from T3.sw;
right
T4: [box "t2"; box "t3"; box "t4"]

text "At time t2" with .e at T2.w
text "At time t3" with .e at T3.w
text "At time t4" with .e at T4.w

----

==== Strided Shift Register
example for

- kernel size: 3
- stride: 2

[pikchr]
----
T2: [box "t0"; box "t2"; box "t4"]

move down 2cm from T2.sw;
right
T3: [box "t2"; box "t4"; box "t6"]
move down 2cm from T3.sw;
right
T4: [box "t4"; box "t6"; box "t8"]

text "At time t4 and t5" with .e at T2.w
text "At time t6 and t7" with .e at T3.w
text "At time t8 and t9" with .e at T4.w


----

==== Deinterleaver/Interleaver

[pikchr]
----

box fill aquamarine "t0"; box fill aquamarine "t1"; box fill aquamarine "t2"; B: box fill yellow "t0"; box fill yellow "t1"; box fill yellow "t2"
move down 2.8cm from first box.w;

right;
box fill aquamarine "t0"; box fill yellow "t0"; box fill aquamarine "t1"; A: box fill yellow "t1"; box fill aquamarine "t2"; box fill yellow "t2"

arrow from 0.2cm south of B.sw to 0.2cm north of A.nw thickness 4pt;

----

==== Lutron

==== Lutron Filter

[pikchr]
----

box "lutron" "0" ; arrow from 1cm north of last box.n to last box.n;

box "lutron" "1" with .w at last box.e; arrow from 1cm north of last box.n to last box.n;

box "lutron" "2" with .w at last box.e; arrow from 1cm north of last box.n to last box.n;

----

== Timing

The timing diagram below shows an example for a simple network featuring three layers.
We feed input data from the following array

[source, vhdl]
----
type input_data_t is array(0 to 7) of std_logic_vector(2 downto 0);

constant input_data : input_data_t := ('000', '001', '010', '011', '100', '101', '110', '111')
----

The layers perform the following operations:

|===
|Layer | h1 | h2 | h3

| *function* \(f(x) =\)
| \( x\)
| \(x_0 + x_1\)
| \(\lfloor{(2^4x_0 + x_1) \div 4}\rfloor \bmod 2\)

|*kernel size*
|1
|2
|2

|*in channels*
|3
|3
|4

|*out channels*
|3
|4
|1


|*stride*
| 1
|1
|2

|===



.Timing Diagram Example
[wavedrom]
----
{signal: [
  {name: 'global clk', wave:                   'P.......................'},
  {name: 'input clk', wave: 'HlHlHlHlHlHlHlHlHlHlHlHl'},
    {name: 'enable', wave: 'lh.....................l'},
  {name: 'input data/h1 d_in', wave: 'x.=.=.=.=.=.=.=.=.x.....', data: ['000', '001', '010', '011', '100', '101', '110', '111']},
  {name: 'h1 d_out/buffer1 d_in', wave: 'x.=.=.=.=.=.=.=.=.x.....', data: ['000', '001', '010', '011', '100', '101', '110', '111']},
  {name: 'buffer1 wr', wave: 'lHlHlHlHlHlHlHlHlHlHlHlH'},
  {name: 'buffer1 d_out/h2 d_in', wave: 'x..=.=.=.=.=.=.=.=.xxxxx', data: ['UUU 000', '000 001', '001 010', '010 011', '011 100', '100 101', '101 110', '110 111']},
  {name: 'h2 d_out/buffer2 d_in', wave: 'x..=.=.=.=.=.=.=.=.xxxxx', data: ['0000', '0001', '0011', '0101', '0111', '1001', '1011', '1101']},
  {name: 'buffer2 wr', wave: 'l.H.l.H.l.H.l.H.l.H.l.H.'},
  {name: 'buffer2 d_out/h3 d_in', wave: 'x.....=...=...=...=...xx', data: ['0000 0001', '0011 0101', '0111 1001', '1011 1101']},
  {name: 'h3 d_out/output', wave: 'x......=...=...=...=...x', data: ['1', '0', '1', '0']},
  {name: 'valid??', wave: 'l.......h.l.h.l.h.l.h.l.'}

],
  head:
  {text: [
  	'tspan', {dy: '-20'}, 'Lutron Timing',
      ['tspan', {dy: '20', dx: '-300'}, 'h1: [c_in: 3, c_out: 3, k: 1, str: 1]'],
      ['tspan', {dx: 20}, 'h2: [c_in: 3, c_out: 4, k: 2, str: 1]'],
      ['tspan', {dx: 20}, 'h3: [c_in: 4, c_out: 1, k: 2, str: 2]'],
	],
   tick:0,
   every:2
 }}
----


The code responsible for network generation has to determine the number of clock cycles until the first rising edge of the signal called _valid??_.
Therefore, we will now have a deeper look at how to derive that number.

=== Computing network latency

We describe a network with \(N\) layers as a composition of functions \(h_1 \circ h_2 \circ \ldots \circ h_N\). Additionally, we say that each of these functions \(h_i\) can be described as follows

\[h_i(\mathbf{x}) = \sum_{j=0}^{N_i}  f_i(x_j, \cdots, x_{j+k}) \mathbf{e}_j \]
where \(\mathbf{e}_j\) is the \(j\)-th unit vector and \(N_i\) is the dimension of \(\text{Im}(h_i)\), ie., the output dimension of the layer.
Now we can identify each of the layers \(h_i\) with the application of a kernel \(f_i\).

IMPORTANT:  Todo: need to make the above formalism apply to tensors (in_channels, out_channels) correctly. All of this is not sound in the context of tensors instead of vectors, even though the derived numbers and conclusions should be correct.

Assuming that we can apply a kernel \(f_i\) with each rising edge of a clock and application of that kernel takes virtually no time, we want to discuss the latency introduced by the buffers, that are introduced before and after kernels to form \(h_i\) from \(f_i\).

We can identify the following cases:

1. Input dimension of \(f_{n+1}\) and output dimension of \(f_{n}\) are equal.
+
In this case we have \(h_{n+1} \circ h_n (\mathbf{x}) = \sum_{j=0}^{N_{n+1}}  f_{n+1} \circ f_n (x_j, \cdots, x_{j+k}) \, \mathbf{e}_j\).
Thus, no buffer is needed between the two kernels.
Note that this is the case, if \(h_{n+1}\) performs a pointwise convolution.
2. We need multiple steps of kernel \(f_i\) to provide enough data for kernel \(f_{i+1}\).
3. We need to apply \(f_{i+1}\) with a stride bigger than 1 (\(s_{i+1} > 1\)). Thus, we need to ignore certain outputs produced by \(h_{i}\).
4. Combination of 2. and 3.

We assume further (for simplification) that each individual layer operates fully sequentially (no kernel unfolding applied).

Let \(T_{n-1} \in \mathbb{N}_0\) denote the number of clock cycles it takes until a valid result can be read from layer \(h_{n-1}\) after feeding the first input time step at the rising edge to the network (time step 2 in Figure 1).

Again for simplification we temporarily assume -- contrary to the above -- that we use a buffer even before layers of kernel size 1.
This will introduce a delay of a single clock cycle, ie., after applying an input signal on a rising edge, we can read the output on the next rising edge.
Let layer \(h_1\) apply a kernel \(f_1\) of size \(k_1 > 1\).
Let further be \(T_0 = l_0 + t_0\), where \(l_0\) denotes the clock cycles until \(h_0\) produces its first output and \(t_0\) the number of clock cycles it takes for each following time step of the input data. As we assume that input data is fed at clock speed we obtain \(T_0 = l_0 = 2(k_0 - 1)\).
Appending a layer with a stride of one and kernel size two we obtain
\[T_1 = T_0 + 1 + 2(k_1 - 1)\]
as \(T_0\) is the time to provide the first time step for the kernel, and we need to wait a two clock cycles for the second time step to be fed to the first layer and another cycle until the output buffers data out line takes on the correct state.
We introduce a single cycle of latency for each buffer we use, just because it will take a cycle until a signal applied to the input will be visible at the output.
\[T_1 = l_0 + 1 + (k_1-1)\]

If the first layer was to use a stride of two (\(s_0 = 2\)), we would obtain
\[T_0 = l_0\]
but
\[T_1 = T_0 + 2s_0(k_1 - 1)\]

Continuing like this we end up with
\[T_N = 2L_{min} + N\] where \(L_{min}\) denotes the minimum length of a sample that we want to process with our network.

=== Passed Through Clock Signals

[wavedrom]
----
{signal: [
    {name: 'enable', wave: 'lh.....................l'},
  {name: 'global clk', wave: 'P.......................'},
  {name: 'sliding_window in clk', wave: 'P.......................'},
{name: 'sliding_window valid', wave:'lHlHlHlHlHlHlHlHlHlHlHlH'},
{name: 'sr 1 clk_in', wave: 'lHlHlHlHlHlHlHlHlHlHlHlH'},
  {name: 'input data/h1 d_in', wave: 'x.=.=.=.=.=.=.=.=.x.....', data: ['000', '001', '010', '011', '100', '101', '110', '111']},
  {name: 'h1 d_out/sr1 d_in', wave: 'x.=.=.=.=.=.=.=.=.x.....', data: ['000', '001', '010', '011', '100', '101', '110', '111']},
  {name: 'sr1 ready', wave: 'HlHlHlHlHlHlHlHlHlHlHlHl'},
  {name: 'sr1 d_out/h2 d_in', wave: 'x..=.=.=.=.=.=.=.=.xxxxx', data: ['UUU 000', '000 001', '001 010', '010 011', '011 100', '100 101', '101 110', '110 111']},
  {name: 'h2 d_out/sr2 d_in', wave: 'x..=.=.=.=.=.=.=.=.xxxxx', data: ['0000', '0001', '0011', '0101', '0111', '1001', '1011', '1101']},
  {name: 'sr2 clk_in', wave: 'l.H.l.H.l.H.l.H.l.H.l.H.'},
  {name: 'sr2 d_out/h3 d_in', wave: 'x.....=...=...=...=...xx', data: ['0000 0001', '0011 0101', '0111 1001', '1011 1101']},
  {name: 'h3 d_out/output', wave: 'x......=...=...=...=...x', data: ['1', '0', '1', '0']},
  {name: 'valid??', wave: 'l.......h.l.h.l.h.l.h.l.'}

],
  head:
  {text: [
  	'tspan', {dy: '-20'}, 'Lutron Timing',
      ['tspan', {dy: '20', dx: '-300'}, 'h1: [c_in: 3, c_out: 3, k: 1, str: 1]'],
      ['tspan', {dx: 20}, 'h2: [c_in: 3, c_out: 4, k: 2, str: 1]'],
      ['tspan', {dx: 20}, 'h3: [c_in: 4, c_out: 1, k: 2, str: 2]'],
	],
   tick:0,
   every:2
 }}
----
